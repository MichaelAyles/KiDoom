# KiCad macOS Crash Fix - Thread Safety Issue

## Problem Summary

KiDoom was crashing KiCad on macOS with the following error:

```
Exception Type:    EXC_CRASH (SIGABRT)
Termination Reason: Namespace SIGNAL, Code 6 Abort trap: 6
```

The crash occurred when trying to create a popup window (`STATUS_POPUP::STATUS_POPUP`) during a `pcbnew.Refresh()` call.

## Root Cause Analysis

### Threading Architecture

The plugin uses a multi-threaded architecture:

1. **Main Thread**: Runs KiCad UI and the plugin's `Run()` method
2. **Background Thread**: Created in `doom_bridge.py` (line 124) to receive frames from the DOOM process without blocking the UI

```python
# doom_bridge.py, line 124
self.thread = threading.Thread(target=self._receive_loop, daemon=True)
self.thread.start()
```

### The Critical Bug

The background thread's receive loop calls `renderer.render_frame()`:

```python
# doom_bridge.py, line 177
self.renderer.render_frame(data)
```

Which in turn calls `pcbnew.Refresh()` from the **background thread**:

```python
# pcb_renderer.py, line 147 (BEFORE FIX)
pcbnew.Refresh()
```

### Why This Crashes on macOS

**wxWidgets/AppKit Threading Rule**: All UI operations must happen on the main thread.

On macOS, `pcbnew.Refresh()` triggers internal KiCad operations that create UI elements (like `STATUS_POPUP` windows). When these are created from a background thread, wxWidgets/AppKit detects the violation and crashes the application with `SIGABRT`.

**Crash Stack Trace**:
```
Thread 18 (Background) Crashed:
  pcbnew.Refresh()
  → PCB_EDIT_FRAME::RebuildAndRefresh()
  → TOOL_MANAGER::ResetTools()
  → EDIT_TOOL::Reset()
  → STATUS_TEXT_POPUP::STATUS_TEXT_POPUP(wxWindow*)
  → [NSPanel initWithContentRect:styleMask:backing:defer:]
  → objc_exception_throw
  → abort()
```

The exception message from macOS:
```
-[NSPanel initWithContentRect:styleMask:backing:defer:] called from a
secondary thread
```

## Solution

Use `wx.CallAfter()` to marshal the `Refresh()` call back to the main thread:

```python
# pcb_renderer.py (AFTER FIX)
import wx

# In render_frame():
try:
    # CallAfter marshals the call to the main UI thread
    wx.CallAfter(pcbnew.Refresh)
except Exception as e:
    # Fallback to direct call (may crash on macOS if not main thread)
    if DEBUG_MODE:
        print(f"WARNING: wx.CallAfter failed, using direct Refresh: {e}")
    pcbnew.Refresh()
```

### How wx.CallAfter Works

`wx.CallAfter(function, *args)` is a wxWidgets function that:

1. Queues the function call on the main thread's event queue
2. Returns immediately (non-blocking)
3. Executes the function on the main thread when the event loop processes it

This is the **standard pattern** for thread-safe UI updates in wxWidgets applications.

## Files Modified

### 1. `kicad_doom_plugin/pcb_renderer.py`

**Added import**:
```python
import wx
```

**Modified `render_frame()` method** (line 147):
- Changed direct `pcbnew.Refresh()` call to `wx.CallAfter(pcbnew.Refresh)`
- Added try/except with fallback for safety

**Modified `cleanup()` method** (line 470):
- Changed direct `pcbnew.Refresh()` call to `wx.CallAfter(pcbnew.Refresh)`
- Same try/except pattern

## Testing Recommendations

### Before Testing
1. **Quit any running KiCad instances** completely
2. **Clear KiCad's plugin cache** (if applicable)
3. **Reload the plugin** in KiCad

### Test Plan

1. **Basic Launch Test**:
   - Open KiCad PCBnew
   - Load any PCB (or create blank)
   - Run "Tools → External Plugins → DOOM on PCB"
   - **Expected**: DOOM launches without KiCad crashing

2. **Gameplay Test**:
   - Play DOOM for 30-60 seconds
   - Move around, shoot, interact
   - **Expected**: PCB traces animate, no crashes

3. **Multiple Sessions**:
   - Quit DOOM (ESC key)
   - Run plugin again
   - **Expected**: Works multiple times

4. **Long Session**:
   - Play for 5+ minutes
   - **Expected**: Stable performance, no crashes

### Expected Behavior

- ✅ KiCad should **not** crash when launching DOOM
- ✅ PCB traces should animate in real-time
- ✅ Frame rate: 10-25 FPS (depends on hardware)
- ✅ Clean shutdown when quitting DOOM

### Potential Issues

1. **Refresh timing**: `wx.CallAfter()` is asynchronous, so there might be a 1-frame delay in rendering
   - **Impact**: Minimal (16-33ms delay at 30-60 FPS)
   - **Mitigation**: Acceptable for a tech demo

2. **Event queue overflow**: If frames arrive faster than the main thread can process
   - **Impact**: Frames might be dropped
   - **Mitigation**: DOOM sends frames at ~35 FPS max, well within UI thread capacity

## Why This Only Affects macOS

**Windows/Linux**: More permissive with UI threading, often allow cross-thread calls (though not recommended)

**macOS (AppKit)**: Strictly enforces main-thread UI operations. Will crash immediately if violated.

**wxWidgets**: Documents that UI calls must be on main thread, but enforcement varies by platform.

## Alternative Solutions Considered

### 1. Move Rendering to Main Thread ❌
**Why not**: Would block KiCad UI during gameplay, making the editor unresponsive.

### 2. Use Mutex/Locks ❌
**Why not**: Doesn't solve the threading issue - the call still happens on the wrong thread.

### 3. Disable Refresh ❌
**Why not**: User wouldn't see DOOM rendering (defeats the entire purpose).

### 4. Use wx.CallAfter (CHOSEN) ✅
**Why**: Standard wxWidgets pattern for cross-thread UI updates, minimal performance impact.

## Performance Impact

**Negligible**:
- `wx.CallAfter()` overhead: < 0.1ms
- Event queue processing: Happens during normal UI event loop
- Frame drops: Unlikely (UI thread can process 60+ FPS easily)

**Benchmarks** (expected):
- Before fix: N/A (crash)
- After fix: 10-25 FPS (same as target performance)

## Verification

To verify the fix works:

```bash
# Run KiCad with the plugin
# Check console for any threading warnings
# Monitor for crashes during gameplay

# Expected output (no errors):
✓ DOOM process started (PID: XXXXX)
✓ Input handler started
     DOOM IS RUNNING!
Controls:
  WASD          - Move
  ...
```

## Long-Term Improvements

1. **Add threading assertions**:
   ```python
   import threading
   assert threading.current_thread() == threading.main_thread(), \
       "Refresh must be called from main thread!"
   ```

2. **Frame rate limiter**: Prevent event queue overflow
   ```python
   # Limit to 30 FPS max
   min_frame_time = 1/30
   if time.time() - last_frame < min_frame_time:
       return  # Skip frame
   ```

3. **Performance metrics**: Track CallAfter latency
   ```python
   callafter_start = time.time()
   wx.CallAfter(pcbnew.Refresh)
   # Measure time until refresh completes
   ```

## References

- **wxWidgets Thread Documentation**: https://docs.wxwidgets.org/3.0/overview_thread.html
- **KiCad Plugin API**: https://docs.kicad.org/doxygen-python/
- **AppKit Threading Rules**: https://developer.apple.com/documentation/appkit

## Credits

**Issue Diagnosed**: Analysis of macOS crash report
**Solution Implemented**: wx.CallAfter threading fix
**Test Platform**: macOS 15.6.1, KiCad 9.0.2, M1 MacBook Pro
